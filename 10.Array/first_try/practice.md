# 問題1: テキストファイルを読み込んで配列処理(レベル4)
1. input.txt というテキストファイルに複数行の文字列が書かれているとします。
2. Rubyスクリプトでファイルを読み込み、各行を配列に格納してください。
3. 取得した配列から、重複行を除去 して（uniq を活用）アルファベット順に sort した結果を標準出力へ表示してください。
4. ファイルが存在しない場合に begin-rescue で例外処理を行い、「ファイルが見つかりません」というエラーを出力して終了してください。
## ポイント:

* File.read や File.foreach などでファイルを読み込む
* 読み込んだ内容を split("\n") などで行単位に分割し、配列化する
* uniq, sort のシンプルな利用
* 例外処理 begin-rescue の導入

# 問題2 標準入力からユーザに文字列を複数回入力させて配列を作る(レベル4)
1. ユーザに「好きな食べ物を入力してください（終了時は空行）」などと促し、複数回入力を受け取る。
2. 空行が入力されたら入力受付を終了し、入力された文字列の配列 を作成する。
3. 配列を逆順（reverse）で表示し、「入力数: N件」という情報を最後に出力する。
4. コードをメソッドに切り出すなど、最低限のリファクタリングを行ってください。
## ポイント:

* while gets や loop do ... break などで標準入力を受け取る
* reverse を使った単純な並べ替え
* メソッド分割（例: def collect_foods）などで読みやすい構成に

# 問題3: 配列操作に関するRSpecテストを記述する(レベル5)
1. Rubyファイル（array_exercise.rb など）に以下のメソッドを定義してください。
```ruby
# 与えられた文字列配列から、「文字数が5文字以上の要素」だけを返すメソッド
def filter_long_words(words)
  # 実装する
end
```
2. 別ファイルでRSpecテストを書き、filter_long_words(["apple", "dog", "banana"]) を実行したとき、結果が ["apple", "banana"] になることをテストしてください。
3. テストを実行して、グリーンになることを確認しましょう。
## ポイント:

* select / reject などで要素をフィルタリングする
* RSpec の expect(actual).to eq(expected) などの基本的な書き方に慣れる

# 問題4: CSVデータの読み込みとソート(レベル5)
1. users.csv が以下のような形式で与えられます。（ヘッダ行あり）
```csv
name,age
Alice,30
Bob,25
Carol,35
```
2. これを読み込んで、[{name: "Alice", age: 30}, {name: "Bob", age: 25}, ...] のような配列として扱ってください。
3. 配列を age 昇順（年齢が小さい順）にソートし、結果を出力してみましょう。
## ポイント:

1. CSVを読み込み→ハッシュの配列を作成→sort_byで年齢順ソート
2. CSV操作にはRuby標準ライブラリ require 'csv' を利用
3. 実務でよくある「CSVを読み込んで何か処理」は非常に典型的


# 問題5: 配列を使ったタスクの一括更新機能（擬似的なRailsモデル想定）(レベル6)
以下のような Task クラス（擬似的なモデル）を定義したとします。
```ruby
class Task
  attr_accessor :title, :done

  def initialize(title, done=false)
    @title = title
    @done = done
  end
end
```
2. タスクの配列 tasks = [Task.new("買い物"), Task.new("掃除"), Task.new("部屋の模様替え")] が与えられたとき、未完了のものだけを完了(true) に更新するメソッド complete_all(tasks) を作成してください。
3. メソッドの実装方針は次のとおりです。
    * 破壊的に更新 してよい（eachで回して done = true にするイメージ）
    * 更新後の配列を戻り値として返す
4. テストを兼ねて、完了ステータスが意図通りに変更されているかどうかを確認してみましょう（putsやRSpecなどお好みで）。
## ポイント:

* 「配列 + クラスのインスタンス」のよくある組み合わせ
* each や map を使った更新ロジック
* 実務では「一括更新API」などで似たような操作を行うシーンがある

# 問題6: 多重配列のフラット化と集計(レベル6)
1. ブログの記事データを「カテゴリごと」に配列で持っているとします。
```ruby
articles_by_category = [
  ["Ruby入門", "Rails実践"],
  ["AWS概要", "Linux基礎", "Docker超入門"],
  ["JavaScript ES6", "Node.js活用"]
]
```
2. この多重配列を flatten して、「全ての記事タイトルを1次元配列で取得」してください。
3. 記事数を標準出力で表示し、併せてソート（アルファベット順など）して一覧表示してください。
4. カウントや並べ替えなど、実際に表示や集計を行う機能を意識して実装してみましょう。
## ポイント:

* flatten の実務使用例
* ソートして表示するだけでも実務の「一覧画面表示」に近い処理

# 問題7 大量データに対してmap/rejectの性能を検証しよう(レベル7)
1. 100万件程度の数値を要素とする配列を Array.new(1_000_000) { rand(1..100) } で作成してください。
2. 以下の2つの処理を行うスクリプトを書き、処理時間を比較・計測してみましょう。（Time.now または Benchmark ライブラリを使用）
  * map でそれぞれの要素を2倍にした新しい配列を作る
  * reject で50未満の要素を除外した新しい配列を作る
3. 大量データを扱う場合、どれくらい時間がかかるかを把握し、パフォーマンスの観点から「破壊的に行うか」「イミュータブルに行うか」を検討材料にする練習をしてください。
## ポイント:

* 大規模なデータ（メモリ負荷、処理時間）を意識したテスト
* Benchmark.measure や Benchmark.bm などで簡易ベンチマークを取る
* 実務でもレコード数が多い場合の配列操作でパフォーマンスを意識するシーンがある

# 問題8 配列とメタプログラミングを交えたユーティリティモジュール(レベル7)
1. 「特定クラスのインスタンス配列」を受け取り、指定された属性の一覧をArrayで返すユーティリティメソッドを定義します。
例:

```ruby
class User
  attr_accessor :name, :age
  def initialize(name, age)
    @name = name
    @age = age
  end
end

module ArrayUtils
  # users: Userインスタンスの配列
  # attr_name: シンボル(:nameや:age)を想定
  # → usersからattr_nameの値だけを取り出し配列で返す
  def self.pluck(users, attr_name)
    # 実装
  end
end
```
2. method_missing や define_method を使った方法で「ダイナミックに pluck する」仕組みを考えてもOKです。（高度なので必須ではありません）

3. ArrayUtils.pluck(users, :name) → ["Alice", "Bob", "Carol"] のように動作するかテストコードなどで確認してください。

## ポイント:

* 実務でも ActiveRecord の pluck や map(&:xxx) を活用するシーンは多い
* メタプログラミングを使うと、動的にメソッドを生やす「簡易ORM」的な実装例も作成可能
* 「配列とクラスインスタンス・属性」の組み合わせが業務システムでは頻出
