※エラー処理・例外処理の理解度が低かったのでレベル4の問題を5問解く

# レベル4_1
## 問題
Rubyで、指定したファイルの内容を読み込み、その内容を画面に出力するメソッド read_file_contents を作成してください。
ファイルが存在しない場合、Rubyでは Errno::ENOENT が発生しますが、このエラーが起きた場合はプログラムを落とさずに「ファイルが見つかりませんでした」と表示したうえで、戻り値として nil を返すようにしてください。

## ポイント
begin ... rescue ... end ブロックを使って例外を捕捉する。
Rubyでファイルを開く際に起こり得るエラーを想定する。

# レベル4_2
## 問題 
ユーザーから文字列を受け取り、整数に変換して返すメソッド to_int_safely を作成してください。

文字列が数値に変換できない場合、例外(ArgumentError など)が起きる可能性があります。
変換に失敗した際は nil を返すように実装してください。
## ポイント

文字列を整数に変換する際に Integer() メソッドが使えます。
begin ... rescue ... end を用いて変換エラーをキャッチし、nil を返す。

# レベル4_3
## 問題 
ユーザーが入力した文字列をファイル名とみなし、ファイルを書き込みモードで開いて何かしらの内容を書き込むメソッド write_to_file を作成してください。

ファイルを開けなかった場合(ディレクトリ名をファイル名に指定してしまうなど)のエラー(Errno::EISDIR 等)をキャッチし、「書き込みできませんでした」と表示したうえで処理を続行してください。
エラーが起きなかった場合は、書き込み完了を示すメッセージ「ファイルに書き込みました」を表示する。
## ポイント

File.open(file_path, "w") でファイルが開けない場合、Errno::EISDIR などが発生する可能性あり。
特定のエラーのみを捕捉するか、StandardError などでも一旦捕捉してもよい。
# レベル4_4
## 問題 
ユーザーが入力した金額を割り勘するメソッド split_bill(amount, number_of_people) を作成してください。

amount(合計金額) と number_of_people(人数) は整数で受け取る。
number_of_people が 0 の場合は ZeroDivisionError が起こるので、例外をキャッチして「人数が0です」と表示し、nil を返すようにする。
上記以外のエラーが発生した場合もキャッチし、エラー内容を表示して nil を返すようにする。


## ポイント


割り算で number_of_people が 0 なら ZeroDivisionError。
数値型でないものが渡される場合など、他のエラーも rescue できるようにしておく。

# レベル4_5
## 問題 
File.read でファイルの内容を読み込み、その行数を返すメソッド count_file_lines を作成してください。

ファイルが存在しない場合 (Errno::ENOENT) は「ファイルが存在しません」と表示し、-1 を返す。
ファイルを読み込む際に他のエラーが起こった場合は、そのエラー内容を表示し、-1 を返す。
## ポイント
File.read はファイルを一度に全て読み込む。行数を数えるには String#lines を使うか、 split("\n") などの方法がある。
特定のエラーをピンポイントで救済(rescue)しつつ、その他を包括的に救済する例を示す。




# レベル5_1
## 問題
引数として受け取ったファイルパス file_path が空文字列の場合には ArgumentError を発生させ、それ以外の場合にはファイルの内容を読み込むメソッド safe_read_file を作成してください。

ファイルが存在しない場合 (Errno::ENOENT) にも対応し、「ファイルが存在しません」というエラーメッセージを出したあと、再度同じ例外を発生させる(再スロー) かたちにしてください。
## ポイント
raise を用いて ArgumentError を発生させる。
rescue 節の中から、再度例外を発生させる(再スロー)には raise を使う。

# レベル5_2
## 問題
InvalidParamError というカスタム例外クラスを定義。
メソッド calculate_square(value) は、引数が数値以外の場合に InvalidParamError を発生させる。
数値の場合は2乗を返す。
## ポイント
1. カスタム例外の定義

    * Rubyでは class InvalidParamError < StandardError; end のように定義できます。
    * 標準的な例外クラス (StandardError, RuntimeError など) から派生させるのが一般的。
2. 引数が数値かどうかの判定

    * Rubyでは value.is_a?(Numeric) で数値型かどうかをチェック可能。
    * Integer(value) のように変換を試みて rescue ArgumentError で拾う方法もあるが、設計の都合でどちらかに統一する。
3. 例外発生 (raise)

    * raise InvalidParamError, "数値ではありません: #{value.inspect}" のようにメッセージを付与して発生させる。
    * 呼び出し元は rescue InvalidParamError => e でキャッチして適切に処理を決定。
4. 正常時の戻り値

    * 数値型の場合は value**2 (2乗) を返す。
    * 例外処理と正常処理を明確に分岐させるのがポイント。
# レベル5_3
## 問題
メソッド open_user_account(username, age) を作成。
username が空文字列、または age が 0 未満なら ArgumentError を発生させる。
"users.txt" へのファイル書き込みに失敗した場合はログを出力して再スローする。
## ポイント
1. 複数のバリデーション

    * username が空文字列(.empty?)かどうかチェック。
    * age < 0 かどうかをチェック。
不正入力を早期に検出し、raise ArgumentError することで後続処理を行わない。
2. ファイル操作での例外処理

    * File.open("users.txt", "a") 等で書き込みを行うが、パーミッションエラーや存在しないディレクトリ等で StandardError が発生する可能性がある。
    * ここでは「特定のファイル操作エラーがあった場合にログを出力→同じ例外を再スロー」という流れが重要。
3. 再スロー (再度raise) の活用

    * rescue StandardError => e で捕捉して puts "..." などのログを入れたあと、 raise すると呼び出し元にも同じ例外が伝わる。
    * 「ファイル書き込み時の失敗を握りつぶさずに、呼び出し元のレベルで扱えるようにする」ことが目的。
4. 呼び出し元での対処

    * rescue ArgumentError => e などで入力引数のエラーをハンドリング。
    * rescue => e でファイル書き込みの失敗を最終的に処理する。
# レベル5_4
## 問題
空文字列であれば ArgumentError。
JSON.parse が失敗したら JsonDataError(カスタム例外) を発生させる。
## ポイント
1. 空文字チェック → ArgumentError
    * 「そもそも JSON 文字列として無効」という扱い。
    * 入力の有効性をまずチェックし、不備があればすぐエラーにする “バリデーション” 的発想。
2. JSON.parse のエラー

    * Ruby の標準ライブラリでは、不正な JSON を与えると JSON::ParserError が発生。
    * これをカスタム例外 JsonDataError としてラップして投げることで、呼び出し側が「JSON パース失敗」を判別しやすくなる（独自メッセージなども付与可能）。
3. カスタム例外の定義

    * class JsonDataError < StandardError; end のように定義。
    * 「JSON パースに失敗した」という明確な意味を持った例外クラスとして活用できる。
4. 呼び出し元でのハンドリング

    * rescue ArgumentError → 引数が空だったときの処理。
    * rescue JsonDataError → JSON データが不正だったときの処理。
    * エラー原因が違う2パターンを分けて扱える。
# レベル5_5
## 問題
メソッド fetch_data_with_retry を定義し、外部API呼び出しを想定したダミーメソッドを使う。
3回までリトライし、失敗したら再スローする。

## ポイント
1. リトライロジック

    * 例えば begin ... rescue ... retry の流れを利用。
    * リトライ回数をカウントして、一定数に達したら諦めて(=再スローして)呼び出し元にエラーを返す。
2. エラーの種類

    * 外部API呼び出し時には SocketError や Timeout::Error など様々な StandardError が起こり得る。
    * 演習では単に raise "API Error!" として疑似的に表現する場合が多い。
3. 再スローと呼び出し元への伝搬

    * リトライをしても解決しなかった場合、 raise e で例外を上位レイヤーに渡す。
    * ここで捕捉しなくてもよいが、上位で救済しないとそのままプログラムがクラッシュする可能性がある。
4. ユーザへのフィードバック / ログ

    * リトライ回数をログ出力する、puts "リトライ中... (x回目)" のように状況を示す。
    * 実運用では、リトライのインターバル（sleep(1) など）や最大リトライ回数を設定しすぎると逆に応答が遅くなるため、要検討。

# レベル6
## 問題
JSONファイルを読み込み、そのデータをハッシュとして返すメソッド load_json_file を作成してください。以下の要件を満たすこととします。

指定されたファイルが存在しない場合 (Errno::ENOENT) は、nil を返す。
JSONパースに失敗した場合 (JSON::ParserError) は、エラーを標準出力に表示して nil を返す。
例外が発生しなくても、最後に「ファイル読み込み処理終了」を表示する (ensure を使う)。
## ポイント
require 'json' が必要。
複数の種類の例外に対して rescue で分岐する。
ensure ブロックで必ず実行される処理を定義する。

# レベル7
## 問題
Rubyを用いた大規模Webアプリケーションにおいて、以下のような複数レイヤー構造を想定しています。

Controller(コントローラ)層: ユーザーからのリクエストを受け取り、サービス層を呼び出す。
Service(サービス)層: ビジネスロジックをまとめ、DBアクセスや外部API呼び出しなどをリポジトリ層に依頼する。
Repository(リポジトリ)層: 実際のDB操作や外部サービスとの通信処理を行う。
以下の要件を満たすアーキテクチャとして、どのように例外を定義・救済(rescue)・再スローし、最終的にエラーレスポンスを返却するか示してください。

DB操作中に発生する例外は、独自に定義した DatabaseError (例: class DatabaseError < StandardError; end) としてラップして Repository 層から Service 層へスローする。
Service 層では、DatabaseError を受け取ったらログを出力しつつ必要に応じて再スロー、または別のカスタム例外に変換してコントローラ層へ伝搬させる。
コントローラ層では、受け取った例外の種類に応じてHTTPステータスコード(500や404、422など)を判定し、レスポンスを返す。予期しないエラーが起きた場合は500エラーとする。
## ポイント
カスタム例外クラスの定義 (例: DatabaseError)
レイヤーごとに責務を分割し、どの層で何を rescue し、どう伝搬させるか考慮する。
コントローラでは最終的にエラーメッセージをユーザーへ返却しつつ、ログなどで詳細を記録する。