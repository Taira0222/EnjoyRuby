※エラー処理・例外処理の理解度が低かったのでレベル4の問題を5問解く

# レベル4_1
## 問題
Rubyで、指定したファイルの内容を読み込み、その内容を画面に出力するメソッド read_file_contents を作成してください。
ファイルが存在しない場合、Rubyでは Errno::ENOENT が発生しますが、このエラーが起きた場合はプログラムを落とさずに「ファイルが見つかりませんでした」と表示したうえで、戻り値として nil を返すようにしてください。

## ポイント
begin ... rescue ... end ブロックを使って例外を捕捉する。
Rubyでファイルを開く際に起こり得るエラーを想定する。

# レベル4_2
## 問題 
ユーザーから文字列を受け取り、整数に変換して返すメソッド to_int_safely を作成してください。

文字列が数値に変換できない場合、例外(ArgumentError など)が起きる可能性があります。
変換に失敗した際は nil を返すように実装してください。
## ポイント

文字列を整数に変換する際に Integer() メソッドが使えます。
begin ... rescue ... end を用いて変換エラーをキャッチし、nil を返す。

# レベル4_3
## 問題 
ユーザーが入力した文字列をファイル名とみなし、ファイルを書き込みモードで開いて何かしらの内容を書き込むメソッド write_to_file を作成してください。

ファイルを開けなかった場合(ディレクトリ名をファイル名に指定してしまうなど)のエラー(Errno::EISDIR 等)をキャッチし、「書き込みできませんでした」と表示したうえで処理を続行してください。
エラーが起きなかった場合は、書き込み完了を示すメッセージ「ファイルに書き込みました」を表示する。
## ポイント

File.open(file_path, "w") でファイルが開けない場合、Errno::EISDIR などが発生する可能性あり。
特定のエラーのみを捕捉するか、StandardError などでも一旦捕捉してもよい。
# レベル4_4
## 問題 
ユーザーが入力した金額を割り勘するメソッド split_bill(amount, number_of_people) を作成してください。

amount(合計金額) と number_of_people(人数) は整数で受け取る。
number_of_people が 0 の場合は ZeroDivisionError が起こるので、例外をキャッチして「人数が0です」と表示し、nil を返すようにする。
上記以外のエラーが発生した場合もキャッチし、エラー内容を表示して nil を返すようにする。


## ポイント


割り算で number_of_people が 0 なら ZeroDivisionError。
数値型でないものが渡される場合など、他のエラーも rescue できるようにしておく。

# レベル4_5
## 問題 
File.read でファイルの内容を読み込み、その行数を返すメソッド count_file_lines を作成してください。

ファイルが存在しない場合 (Errno::ENOENT) は「ファイルが存在しません」と表示し、-1 を返す。
ファイルを読み込む際に他のエラーが起こった場合は、そのエラー内容を表示し、-1 を返す。
## ポイント
File.read はファイルを一度に全て読み込む。行数を数えるには String#lines を使うか、 split("\n") などの方法がある。
特定のエラーをピンポイントで救済(rescue)しつつ、その他を包括的に救済する例を示す。


# レベル4_6
## 問題 
「指定した処理を必ず最後に実行したい」という要件がある場合、Rubyの ensure を使って実装する例を示してください。

メソッド process_and_cleanup は、ブロック (yield) で受け取った処理を実行した後、どんなに例外が起きても最後に「クリーンアップ処理」を出力するようにする。
例外が起きた場合は呼び出し側に伝播する(再スロー) 形にする。
## ポイント

begin ... rescue ... ensure ... end を使う。
ensure ブロック内のコードは、rescue で例外を捕まえた後でも必ず実行される。
例外を握りつぶさずに再スロー(もしくは rescue しない)すれば、呼び出し元で例外を拾える。


# レベル5
## 問題
引数として受け取ったファイルパス file_path が空文字列の場合には ArgumentError を発生させ、それ以外の場合にはファイルの内容を読み込むメソッド safe_read_file を作成してください。

ファイルが存在しない場合 (Errno::ENOENT) にも対応し、「ファイルが存在しません」というエラーメッセージを出したあと、再度同じ例外を発生させる(再スロー) かたちにしてください。
## ポイント
raise を用いて ArgumentError を発生させる。
rescue 節の中から、再度例外を発生させる(再スロー)には raise を使う。

# レベル6
## 問題
JSONファイルを読み込み、そのデータをハッシュとして返すメソッド load_json_file を作成してください。以下の要件を満たすこととします。

指定されたファイルが存在しない場合 (Errno::ENOENT) は、nil を返す。
JSONパースに失敗した場合 (JSON::ParserError) は、エラーを標準出力に表示して nil を返す。
例外が発生しなくても、最後に「ファイル読み込み処理終了」を表示する (ensure を使う)。
## ポイント
require 'json' が必要。
複数の種類の例外に対して rescue で分岐する。
ensure ブロックで必ず実行される処理を定義する。

# レベル7
## 問題
Rubyを用いた大規模Webアプリケーションにおいて、以下のような複数レイヤー構造を想定しています。

Controller(コントローラ)層: ユーザーからのリクエストを受け取り、サービス層を呼び出す。
Service(サービス)層: ビジネスロジックをまとめ、DBアクセスや外部API呼び出しなどをリポジトリ層に依頼する。
Repository(リポジトリ)層: 実際のDB操作や外部サービスとの通信処理を行う。
以下の要件を満たすアーキテクチャとして、どのように例外を定義・救済(rescue)・再スローし、最終的にエラーレスポンスを返却するか示してください。

DB操作中に発生する例外は、独自に定義した DatabaseError (例: class DatabaseError < StandardError; end) としてラップして Repository 層から Service 層へスローする。
Service 層では、DatabaseError を受け取ったらログを出力しつつ必要に応じて再スロー、または別のカスタム例外に変換してコントローラ層へ伝搬させる。
コントローラ層では、受け取った例外の種類に応じてHTTPステータスコード(500や404、422など)を判定し、レスポンスを返す。予期しないエラーが起きた場合は500エラーとする。
## ポイント
カスタム例外クラスの定義 (例: DatabaseError)
レイヤーごとに責務を分割し、どの層で何を rescue し、どう伝搬させるか考慮する。
コントローラでは最終的にエラーメッセージをユーザーへ返却しつつ、ログなどで詳細を記録する。