# 1問目
このからポジティブ面のフィードバックも入れることにする

### できたこと
・基本的な実装。chatgpt曰く85点。細かなミス以外はしっかり実装できていました

### できなかったこと

以下のミスがあったので修正
1. 「平均以上」ではなく「平均より大きい」を使っている:
問題文は「平均以上（>=）」としていますが、コードは >（厳密にはfdivなので float ですが）を使用しているため、== 平均値の場合が除外されてしまいます。
2. 平均値が「小数点以下切り捨て」になっていない:
fdiv によって浮動小数で計算されますが、問題文では「小数点以下切り捨て」を求めています。fdiv だけでは小数点以下を切り捨てずにfloatを返し、厳格には要件と異なります。
3. ソートや出力形式:
要件で「昇順にソートして出力」とありますが、最後は p final_process で配列を表示しているだけでソートされていませんし、要件が示す「出力形式」に厳密には合っていない。

細かい実装だったので、filtering1.rbにそのまま修正しました。

# 2問目

## 一回目のコード
### できたこと
うまくコードが動かなかったし、細かい論理であっているところはあったがchatgpt評価は 40点

### できなかったこと
あまりにも多すぎてコードを書き直す必要があったため、内容はそのまま引用
1. 要件の達成度（20点中 10点）
要件としては、「すべての要素が 'fix' になるまで繰り返し処理をし、最終的な配列を出力する」ものですが、現状のコードは要件を満たしている可能性が低いです。
多くの箇所で再帰的に process_until_fix(item) を呼び出していますが、item は配列ではなく単一の値のことが多く、想定通りの動作にはならないケースがあります。
また、最終的に「すべて 'fix'」になった配列を返すというロジックが曖昧で、return itemが途中で呼ばれた場合の挙動が問題になります。

2. 再帰構造・デバッグ難易度（30点中 5点）
この問題の本質は、「全要素が 'fix' になるまで繰り返す」ことですが、再帰を使う場合には各要素を単一で再帰呼び出しする設計が必要です。
現在のコードでは要素（整数 or 文字列）を処理し、その途中で process_until_fix(item) を呼び出しています。
しかし item が配列ではないため、次の呼び出しでは型の不一致や意図しない挙動が生じる可能性が高い。
さらに data.map でブロックの最後に return item が部分的に呼ばれるなど、中途半端に終了してしまうケースがある。
結果として、どのタイミングで全要素が 'fix' になったのかを判定できない構造になっています。

3. Rubyのクラス判定ミス (item.class == "integer" など)（20点中 0点）
Rubyでは、クラス判定をする場合 item.is_a?(Integer) や item.is_a?(String) を使うのが基本で、
item.class == "integer" だと、文字列 "integer" との比較になってしまい、必ず偽になります。
実際には item.class は Integer, String などのクラスオブジェクトを返し、文字列 "integer" と比較しても一致しません。
これによって整数用の分岐が実行されない（あるいは常に偽）という致命的な不具合になる可能性が高いです。

4. 文字列変換ロジック (item_to.s + "ok") のミス（10点中 2点）
item = item_to.s + "ok" という記述がありますが、item_to という変数が定義されておらず、to.s も存在しないメソッド呼び出しです。
正しくは item.to_s + "ok" のように書くべきだと思われますが、そもそも item.class == "integer" がうまく動いていないため、このコードに到達しない可能性もあります。

5. 最終出力が想定どおり行われない（10点中 5点）
コード末尾で p result しているだけで、問題文上は**「最終的に全要素が 'fix' になった配列を出力」** という形ですが、このコードの構造上、一要素ずつ process_until_fix(item) を再帰呼び出ししているため、result が配列ではなく途中で item だけが返される可能性があります。
事実上、mapブロックでreturn itemが呼ばれると配列全体ではなく単一オブジェクトを返してしまい、そのままブロックが終了するなど不整合が発生。

### ミスをした原因や改善点
1. 早期returnの挙動を理解していなかった
通常のif文の場合はreturn を使う必要がないことを認識していませんでした
また、2回目コードを書いている時に気づいたのですが、以下のようなケースの場合
```ruby
def process_until_fix(arr)
    until arr_fix?(arr)
        arr.map! do |elem|
            return "fix" unless elem.is_a?(Integer) || elem.is_a?(String)
            elem == "fix"? "fix" : process_element(elem)
        end
    end
    arr 
end
```
returnをしたらブロックの処理だけでなく、process_until_fixメソッドの処理を終わらせてしまうので
```ruby
def process_until_fix(arr)
    until arr_fix?(arr)
        arr.map! do |elem|
            unless elem.is_a?(Integer) || elem.is_a?(String)
                "fix"
            else
                elem == "fix"? "fix" : process_element(elem)
            end
        end
    end
    arr # つけ忘れ
end
```
と書くのがよい

2. ロジックが別なものを1つのメソッドで行おうとした
これは以前もやってしまったのですが、クラス内でないとメソッドをわけるという発想にならず1つにまとめられませんでした。
本来は以下のメソッドが必要でした
* 計算をする(整数or文字列の処理)
* すべてfixになったかの確認をする
* 上記2つをまとめて処理する

3. 判定の書き方等のrubyの文法を正しく使えなかった
    * `item.class =="integer"`
    この書き方では、サブクラスや互換性のあるオブジェクトを無視することになります。また、Rubyのダックタイピング(そのオブジェクトが何のクラスかよりもどうふるまうか)の原則を無視してしまうのでitem.is_a?(Integer)のほうが適切
    * item ="fix"のように書く必要がなかった
    if文の最後の式を返り値として返すので、単純に "fix" だけでよく冗長であった

## 2回目のコード

### できたこと
型判定 (is_a?) 、多条件の分岐ロジック、メソッド分割の方針はおおむねできていたが、点数は65点

### できなかったこと
1. 要素が整数だった場合と文字列だった場合の処理を「ifを2回」分けて書いている
2. process_element の最後に何も返さなかった場合
これは文字列や整数クラスでないものが入った際の処理、何も書いていないのでnilが返り値となってしまう
3. 全体ループ終了後の戻り値
WhileやUntilの返り値はnilなので、想定している配列が返ってこない

